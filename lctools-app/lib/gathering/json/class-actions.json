[
  {
    "id": "power-rock-strike",
    "class": "miner",
    "level": 2,
    "name": "Power Rock Strike",
    "cost_text": "1 Strike Dice",
    "dice_cost": 1,
    "node_points_cost": 0,
    "lucky_points_cost": 0,
    "is_rapid": false,
    "requires_prerequisite": false,
    "description": "Make a gathering check at only half of your gathering bonus (rounded down) add the rolled amount to both node and lucky points.",
    "effects": [
      { "type": "roll", "dice": { "sides": 10, "count": 1 }, "store_as": "roll" },
      { "type": "calculate", "formula": "roll + Math.floor((gatheringSkill + expertise + toolBonus) / 2)", "store_as": "bonus" },
      { "type": "modify", "target": "currentNP", "operation": "add", "value": "{bonus}" },
      { "type": "modify", "target": "currentLP", "operation": "add", "value": "{bonus}" },
      { "type": "log", "message": "Used Power Rock Strike. Rolled {roll}. Added {bonus} to NP and LP." }
    ]
  },
  {
    "id": "efficient-strike",
    "class": "miner",
    "level": 6,    
    "name": "Efficient Strike",
    "cost_text": "1 Strike Dice",
    "dice_cost": 1,
    "node_points_cost": 0,
    "lucky_points_cost": 0,
    "is_rapid": false,
    "requires_prerequisite": false,
    "description": "Make a gathering check. If this maxes node points, all overflow is converted into lucky points.",
    "effects": [
      { "type": "roll", "dice": { "sides": 10, "count": 1 }, "store_as": "roll" },
      { "type": "calculate", "formula": "roll + gatheringSkill + expertise + toolBonus + ironFocusBonus", "store_as": "bonus" },
      { "type": "calculate", "formula": "Math.min(bonus, nodePoints - currentNP)", "store_as": "npAdded" },
      { "type": "modify", "target": "currentNP", "operation": "add", "value": "{npAdded}" },
      { "type": "calculate", "formula": "bonus - npAdded", "store_as": "lpAdded" },
      { "type": "modify", "target": "currentLP", "operation": "add", "value": "{lpAdded}" },
      { "type": "log", "message": "Used Efficient Strike. Rolled {roll}. Added {npAdded} to NP and {lpAdded} to LP." }
    ]
  },
  {
    "id": "focused-detonation",
    "class": "excavator",
    "level": 2,
    "name": "Focused Detonation",
    "cost_text": "1 Strike Dice",
    "dice_cost": 1,
    "node_points_cost": 0,
    "lucky_points_cost": 0,
    "is_rapid": false,
    "requires_prerequisite": false,
    "description": "Make a gathering check against either Node or Lucky points. If this strike would max it out, you may instead leave it at 1 and gain +1 Strike Dice.",
    "effects": [],
    "effect_code": "(state, utils, logMessage) => {\n  const roll = utils.rollD10();\n  const total = roll + state.gatheringSkill + state.expertise + state.toolBonus;\n  let newState = logMessage(state, `Used Focused Detonation. Rolled ${roll}.`);\n  const key = state.perseveranceTarget === 'LP' ? 'currentLP' : 'currentNP';\n  const limit = state.perseveranceTarget === 'LP' ? state.luckyPoints : state.nodePoints;\n  if (newState[key] + total >= limit) {\n    newState = { ...newState, [key]: 1, diceRemaining: newState.diceRemaining + 1 };\n  } else {\n    newState = { ...newState, [key]: newState[key] + total };\n  }\n  return newState;\n}"
  },
  {
    "id": "take-it-easy",
    "class": "excavator",
    "level": 8,
    "name": "Take It Easy",
    "cost_text": "1 Strike Dice",
    "dice_cost": 1,
    "node_points_cost": 0,
    "lucky_points_cost": 0,
    "is_rapid": false,
    "requires_prerequisite": false,
    "description": "Do not make a gathering check. Instead, immediately collect 25% of the nodeâ€™s base material as a bonus (doesn't affect Node or Lucky progress).",
    "effects": [],
    "effect_code": "(state, utils, logMessage) => {\n  const bonus = Math.floor(state.normalYield * 0.25);\n  let newState = logMessage(state, `Used Take It Easy. Collected 25% bonus yield.`);\n  return newState;\n}"
  },
  {
    "id": "divining-petalfall",
    "class": "forager",
    "level": 6,
    "name": "Divining Petalfall",
    "cost_text": "1 Strike Dice",
    "dice_cost": 1,
    "node_points_cost": 0,
    "lucky_points_cost": 0,
    "is_rapid": false,
    "requires_prerequisite": false,
    "description": "Make a gathering check with a +5 bonus. If the final result is even, add it to Node Points; if odd, add it to Lucky Points.",
    "effects": [],
    "effect_code": "(state, utils, logMessage) => {\n  const roll = utils.rollD10();\n  const total = roll + state.gatheringSkill + state.expertise + state.toolBonus + 5;\n  let newState = logMessage(state, `Used Divining Petalfall. Total result ${total}.`);\n  if (total % 2 === 0) {\n    newState = { ...newState, currentNP: newState.currentNP + total };\n  } else {\n    newState = { ...newState, currentLP: newState.currentLP + total };\n  }\n  return newState;\n}"
  },
  {
    "id": "memory-of-the-grove",
    "class": "botanist",
    "level": 2,
    "name": "Memory of the Grove",
    "cost_text": "1 Strike Dice",
    "dice_cost": 1,
    "node_points_cost": 0,
    "lucky_points_cost": 0,
    "is_rapid": false,
    "requires_prerequisite": false,
    "description": "After making a gathering check, you may reroll the die and store the original result to replace a future roll.",
    "effects": [],
    "effect_code": "(state, utils, logMessage) => {\n  const roll = utils.rollD10();\n  let newState = logMessage(state, `Used Memory of the Grove. Rolled ${roll}.`);\n  return { ...newState, storedRoll: roll };\n}"
  },
  {
    "id": "stalks-of-comparison",
    "class": "botanist",
    "level": 6,
    "name": "Stalks of Comparison",
    "cost_text": "1 Strike Dice",
    "dice_cost": 1,
    "node_points_cost": 0,
    "lucky_points_cost": 0,
    "is_rapid": true,
    "requires_prerequisite": false,
    "description": "Make a gathering check. If this roll (before bonuses) is higher than your previous roll this session, gain a bonus equal to your Foraging skill (max +10).",
    "effects": [],
    "effect_code": "(state, utils, logMessage) => {\n  const roll = utils.rollD10();\n  let newState = logMessage(state, `Used Stalks of Comparison. Rolled ${roll}.`);\n  const prev = state.storedRoll || 0;\n  const prevNP = newState.currentNP;\n  const bonus = roll > prev ? Math.min(state.gatheringSkill, 10) : 0;\n  const newNP = prevNP + bonus;\n  return { ...newState, currentNP: newNP, storedRoll: roll };\n}"
  }
]
